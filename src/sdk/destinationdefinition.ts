/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * DestinationDefinition related resources.
 */
export class DestinationDefinition {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Creates a custom destinationDefinition for the given workspace
   */
  async createCustomDestinationDefinition(
    req: shared.CustomDestinationDefinitionCreate,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateCustomDestinationDefinitionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.CustomDestinationDefinitionCreate(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/v1/destination_definitions/create_custom";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    headers["Accept"] = "application/json;q=1, application/json;q=0";
    headers[
      "user-agent"
    ] = `speakeasy-sdk/${this._language} ${this._sdkVersion} ${this._genVersion}`;

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.CreateCustomDestinationDefinitionResponse =
      new operations.CreateCustomDestinationDefinitionResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.destinationDefinitionRead = utils.objectToClass(
            httpRes?.data,
            shared.DestinationDefinitionRead
          );
        }
        break;
      case httpRes?.status == 422:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.invalidInputExceptionInfo = utils.objectToClass(
            httpRes?.data,
            shared.InvalidInputExceptionInfo
          );
        }
        break;
    }

    return res;
  }

  /**
   * Delete a destination definition
   */
  async deleteDestinationDefinition(
    req: shared.DestinationDefinitionIdRequestBody,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteDestinationDefinitionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.DestinationDefinitionIdRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/v1/destination_definitions/delete";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");
    headers["Accept"] = "application/json;q=1, application/json;q=0";
    headers[
      "user-agent"
    ] = `speakeasy-sdk/${this._language} ${this._sdkVersion} ${this._genVersion}`;

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.DeleteDestinationDefinitionResponse =
      new operations.DeleteDestinationDefinitionResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 204:
        break;
      case httpRes?.status == 404:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.notFoundKnownExceptionInfo = utils.objectToClass(
            httpRes?.data,
            shared.NotFoundKnownExceptionInfo
          );
        }
        break;
      case httpRes?.status == 422:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.invalidInputExceptionInfo = utils.objectToClass(
            httpRes?.data,
            shared.InvalidInputExceptionInfo
          );
        }
        break;
    }

    return res;
  }

  /**
   * Get destinationDefinition
   */
  async getDestinationDefinition(
    req: shared.DestinationDefinitionIdRequestBody,
    config?: AxiosRequestConfig
  ): Promise<operations.GetDestinationDefinitionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.DestinationDefinitionIdRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/v1/destination_definitions/get";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");
    headers["Accept"] =
      "application/json;q=1, application/json;q=0.7, application/json;q=0";
    headers[
      "user-agent"
    ] = `speakeasy-sdk/${this._language} ${this._sdkVersion} ${this._genVersion}`;

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.GetDestinationDefinitionResponse =
      new operations.GetDestinationDefinitionResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.destinationDefinitionRead = utils.objectToClass(
            httpRes?.data,
            shared.DestinationDefinitionRead
          );
        }
        break;
      case httpRes?.status == 404:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.notFoundKnownExceptionInfo = utils.objectToClass(
            httpRes?.data,
            shared.NotFoundKnownExceptionInfo
          );
        }
        break;
      case httpRes?.status == 422:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.invalidInputExceptionInfo = utils.objectToClass(
            httpRes?.data,
            shared.InvalidInputExceptionInfo
          );
        }
        break;
    }

    return res;
  }

  /**
   * Get a destinationDefinition that is configured for the given workspace
   */
  async getDestinationDefinitionForWorkspace(
    req: shared.DestinationDefinitionIdWithWorkspaceId,
    config?: AxiosRequestConfig
  ): Promise<operations.GetDestinationDefinitionForWorkspaceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.DestinationDefinitionIdWithWorkspaceId(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/v1/destination_definitions/get_for_workspace";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");
    headers["Accept"] =
      "application/json;q=1, application/json;q=0.7, application/json;q=0";
    headers[
      "user-agent"
    ] = `speakeasy-sdk/${this._language} ${this._sdkVersion} ${this._genVersion}`;

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.GetDestinationDefinitionForWorkspaceResponse =
      new operations.GetDestinationDefinitionForWorkspaceResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.destinationDefinitionRead = utils.objectToClass(
            httpRes?.data,
            shared.DestinationDefinitionRead
          );
        }
        break;
      case httpRes?.status == 404:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.notFoundKnownExceptionInfo = utils.objectToClass(
            httpRes?.data,
            shared.NotFoundKnownExceptionInfo
          );
        }
        break;
      case httpRes?.status == 422:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.invalidInputExceptionInfo = utils.objectToClass(
            httpRes?.data,
            shared.InvalidInputExceptionInfo
          );
        }
        break;
    }

    return res;
  }

  /**
   * grant a private, non-custom destinationDefinition to a given workspace
   */
  async grantDestinationDefinitionToWorkspace(
    req: shared.DestinationDefinitionIdWithWorkspaceId,
    config?: AxiosRequestConfig
  ): Promise<operations.GrantDestinationDefinitionToWorkspaceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.DestinationDefinitionIdWithWorkspaceId(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/v1/destination_definitions/grant_definition";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");
    headers["Accept"] =
      "application/json;q=1, application/json;q=0.7, application/json;q=0";
    headers[
      "user-agent"
    ] = `speakeasy-sdk/${this._language} ${this._sdkVersion} ${this._genVersion}`;

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.GrantDestinationDefinitionToWorkspaceResponse =
      new operations.GrantDestinationDefinitionToWorkspaceResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.privateDestinationDefinitionRead = utils.objectToClass(
            httpRes?.data,
            shared.PrivateDestinationDefinitionRead
          );
        }
        break;
      case httpRes?.status == 404:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.notFoundKnownExceptionInfo = utils.objectToClass(
            httpRes?.data,
            shared.NotFoundKnownExceptionInfo
          );
        }
        break;
      case httpRes?.status == 422:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.invalidInputExceptionInfo = utils.objectToClass(
            httpRes?.data,
            shared.InvalidInputExceptionInfo
          );
        }
        break;
    }

    return res;
  }

  /**
   * List all the destinationDefinitions the current Airbyte deployment is configured to use
   */
  async listDestinationDefinitions(
    config?: AxiosRequestConfig
  ): Promise<operations.ListDestinationDefinitionsResponse> {
    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/v1/destination_definitions/list";

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...config?.headers };
    headers["Accept"] = "application/json";
    headers[
      "user-agent"
    ] = `speakeasy-sdk/${this._language} ${this._sdkVersion} ${this._genVersion}`;

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.ListDestinationDefinitionsResponse =
      new operations.ListDestinationDefinitionsResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.destinationDefinitionReadList = utils.objectToClass(
            httpRes?.data,
            shared.DestinationDefinitionReadList
          );
        }
        break;
    }

    return res;
  }

  /**
   * List all the destinationDefinitions the given workspace is configured to use
   */
  async listDestinationDefinitionsForWorkspace(
    req: shared.WorkspaceIdRequestBody,
    config?: AxiosRequestConfig
  ): Promise<operations.ListDestinationDefinitionsForWorkspaceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.WorkspaceIdRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/v1/destination_definitions/list_for_workspace";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    headers["Accept"] = "application/json";
    headers[
      "user-agent"
    ] = `speakeasy-sdk/${this._language} ${this._sdkVersion} ${this._genVersion}`;

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.ListDestinationDefinitionsForWorkspaceResponse =
      new operations.ListDestinationDefinitionsForWorkspaceResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.destinationDefinitionReadList = utils.objectToClass(
            httpRes?.data,
            shared.DestinationDefinitionReadList
          );
        }
        break;
    }

    return res;
  }

  /**
   * List the latest destinationDefinitions Airbyte supports
   *
   * @remarks
   * Guaranteed to retrieve the latest information on supported destinations.
   */
  async listLatestDestinationDefinitions(
    config?: AxiosRequestConfig
  ): Promise<operations.ListLatestDestinationDefinitionsResponse> {
    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/v1/destination_definitions/list_latest";

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...config?.headers };
    headers["Accept"] = "application/json";
    headers[
      "user-agent"
    ] = `speakeasy-sdk/${this._language} ${this._sdkVersion} ${this._genVersion}`;

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.ListLatestDestinationDefinitionsResponse =
      new operations.ListLatestDestinationDefinitionsResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.destinationDefinitionReadList = utils.objectToClass(
            httpRes?.data,
            shared.DestinationDefinitionReadList
          );
        }
        break;
    }

    return res;
  }

  /**
   * List all private, non-custom destinationDefinitions, and for each indicate whether the given workspace has a grant for using the definition. Used by admins to view and modify a given workspace's grants.
   */
  async listPrivateDestinationDefinitions(
    req: shared.WorkspaceIdRequestBody,
    config?: AxiosRequestConfig
  ): Promise<operations.ListPrivateDestinationDefinitionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.WorkspaceIdRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/v1/destination_definitions/list_private";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    headers["Accept"] = "application/json";
    headers[
      "user-agent"
    ] = `speakeasy-sdk/${this._language} ${this._sdkVersion} ${this._genVersion}`;

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.ListPrivateDestinationDefinitionsResponse =
      new operations.ListPrivateDestinationDefinitionsResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.privateDestinationDefinitionReadList = utils.objectToClass(
            httpRes?.data,
            shared.PrivateDestinationDefinitionReadList
          );
        }
        break;
    }

    return res;
  }

  /**
   * revoke a grant to a private, non-custom destinationDefinition from a given workspace
   */
  async revokeDestinationDefinitionFromWorkspace(
    req: shared.DestinationDefinitionIdWithWorkspaceId,
    config?: AxiosRequestConfig
  ): Promise<operations.RevokeDestinationDefinitionFromWorkspaceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.DestinationDefinitionIdWithWorkspaceId(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/v1/destination_definitions/revoke_definition";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");
    headers["Accept"] = "application/json;q=1, application/json;q=0";
    headers[
      "user-agent"
    ] = `speakeasy-sdk/${this._language} ${this._sdkVersion} ${this._genVersion}`;

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.RevokeDestinationDefinitionFromWorkspaceResponse =
      new operations.RevokeDestinationDefinitionFromWorkspaceResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 204:
        break;
      case httpRes?.status == 404:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.notFoundKnownExceptionInfo = utils.objectToClass(
            httpRes?.data,
            shared.NotFoundKnownExceptionInfo
          );
        }
        break;
      case httpRes?.status == 422:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.invalidInputExceptionInfo = utils.objectToClass(
            httpRes?.data,
            shared.InvalidInputExceptionInfo
          );
        }
        break;
    }

    return res;
  }

  /**
   * Update destinationDefinition
   */
  async updateDestinationDefinition(
    req: shared.DestinationDefinitionUpdate,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateDestinationDefinitionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.DestinationDefinitionUpdate(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/v1/destination_definitions/update";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");
    headers["Accept"] =
      "application/json;q=1, application/json;q=0.7, application/json;q=0";
    headers[
      "user-agent"
    ] = `speakeasy-sdk/${this._language} ${this._sdkVersion} ${this._genVersion}`;

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.UpdateDestinationDefinitionResponse =
      new operations.UpdateDestinationDefinitionResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.destinationDefinitionRead = utils.objectToClass(
            httpRes?.data,
            shared.DestinationDefinitionRead
          );
        }
        break;
      case httpRes?.status == 404:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.notFoundKnownExceptionInfo = utils.objectToClass(
            httpRes?.data,
            shared.NotFoundKnownExceptionInfo
          );
        }
        break;
      case httpRes?.status == 422:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.invalidInputExceptionInfo = utils.objectToClass(
            httpRes?.data,
            shared.InvalidInputExceptionInfo
          );
        }
        break;
    }

    return res;
  }
}
