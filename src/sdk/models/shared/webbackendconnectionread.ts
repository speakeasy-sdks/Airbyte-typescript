/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { SpeakeasyBase, SpeakeasyMetadata } from "../../../internal/utils";
import { AirbyteCatalog } from "./airbytecatalog";
import { CatalogDiff } from "./catalogdiff";
import { ConnectionSchedule } from "./connectionschedule";
import { ConnectionScheduleData } from "./connectionscheduledata";
import { ConnectionScheduleTypeEnum } from "./connectionscheduletypeenum";
import { ConnectionStatusEnum } from "./connectionstatusenum";
import { DestinationRead } from "./destinationread";
import { GeographyEnum } from "./geographyenum";
import { JobStatusEnum } from "./jobstatusenum";
import { NamespaceDefinitionTypeEnum } from "./namespacedefinitiontypeenum";
import { NonBreakingChangesPreferenceEnum } from "./nonbreakingchangespreferenceenum";
import { OperationRead } from "./operationread";
import { ResourceRequirements } from "./resourcerequirements";
import { SchemaChangeEnum } from "./schemachangeenum";
import { SourceRead } from "./sourceread";
import { Expose, Type } from "class-transformer";

/**
 * Successful operation
 */
export class WebBackendConnectionRead extends SpeakeasyBase {
  /**
   * Describes the difference between two Airbyte catalogs.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "catalogDiff" })
  @Type(() => CatalogDiff)
  catalogDiff?: CatalogDiff;

  @SpeakeasyMetadata()
  @Expose({ name: "catalogId" })
  catalogId?: string;

  @SpeakeasyMetadata()
  @Expose({ name: "connectionId" })
  connectionId: string;

  @SpeakeasyMetadata()
  @Expose({ name: "destination" })
  @Type(() => DestinationRead)
  destination: DestinationRead;

  @SpeakeasyMetadata()
  @Expose({ name: "destinationId" })
  destinationId: string;

  @SpeakeasyMetadata()
  @Expose({ name: "geography" })
  geography?: GeographyEnum;

  @SpeakeasyMetadata()
  @Expose({ name: "isSyncing" })
  isSyncing: boolean;

  /**
   * epoch time of the latest sync job. null if no sync job has taken place.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "latestSyncJobCreatedAt" })
  latestSyncJobCreatedAt?: number;

  @SpeakeasyMetadata()
  @Expose({ name: "latestSyncJobStatus" })
  latestSyncJobStatus?: JobStatusEnum;

  @SpeakeasyMetadata()
  @Expose({ name: "name" })
  name: string;

  /**
   * Method used for computing final namespace in destination
   */
  @SpeakeasyMetadata()
  @Expose({ name: "namespaceDefinition" })
  namespaceDefinition?: NamespaceDefinitionTypeEnum;

  /**
   * Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "namespaceFormat" })
  namespaceFormat?: string;

  @SpeakeasyMetadata()
  @Expose({ name: "nonBreakingChangesPreference" })
  nonBreakingChangesPreference: NonBreakingChangesPreferenceEnum;

  @SpeakeasyMetadata()
  @Expose({ name: "notifySchemaChanges" })
  notifySchemaChanges: boolean;

  @SpeakeasyMetadata()
  @Expose({ name: "operationIds" })
  operationIds?: string[];

  @SpeakeasyMetadata({ elemType: OperationRead })
  @Expose({ name: "operations" })
  @Type(() => OperationRead)
  operations?: OperationRead[];

  /**
   * Prefix that will be prepended to the name of each stream when it is written to the destination.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "prefix" })
  prefix?: string;

  /**
   * optional resource requirements to run workers (blank for unbounded allocations)
   */
  @SpeakeasyMetadata()
  @Expose({ name: "resourceRequirements" })
  @Type(() => ResourceRequirements)
  resourceRequirements?: ResourceRequirements;

  /**
   * if null, then no schedule is set.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "schedule" })
  @Type(() => ConnectionSchedule)
  schedule?: ConnectionSchedule;

  /**
   * schedule for when the the connection should run, per the schedule type
   */
  @SpeakeasyMetadata()
  @Expose({ name: "scheduleData" })
  @Type(() => ConnectionScheduleData)
  scheduleData?: ConnectionScheduleData;

  /**
   * determine how the schedule data should be interpreted
   */
  @SpeakeasyMetadata()
  @Expose({ name: "scheduleType" })
  scheduleType?: ConnectionScheduleTypeEnum;

  @SpeakeasyMetadata()
  @Expose({ name: "schemaChange" })
  schemaChange: SchemaChangeEnum;

  @SpeakeasyMetadata()
  @Expose({ name: "source" })
  @Type(() => SourceRead)
  source: SourceRead;

  @SpeakeasyMetadata()
  @Expose({ name: "sourceId" })
  sourceId: string;

  /**
   * Active means that data is flowing through the connection. Inactive means it is not. Deprecated means the connection is off and cannot be re-activated. the schema field describes the elements of the schema that will be synced.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "status" })
  status: ConnectionStatusEnum;

  /**
   * describes the available schema (catalog).
   */
  @SpeakeasyMetadata()
  @Expose({ name: "syncCatalog" })
  @Type(() => AirbyteCatalog)
  syncCatalog: AirbyteCatalog;
}
